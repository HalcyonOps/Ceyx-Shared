name: Sync Resources
permissions:
  contents: write
  actions: read
  id-token: write

on:
  push:
    paths:
      - 'resources/**'
  workflow_dispatch:

jobs:
  sync-files:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
      id-token: write
    env:
      TARGET_REPOS: |
        https://github.com/HalcyonOps/Ceyx-AWS-EC2.git
        https://github.com/HalcyonOps/Ceyx-AWS-VPC.git
    steps:
      - name: Checkout source repository
        uses: actions/checkout@v4
        with:
          path: source-repo

      - name: Install dependencies
        run: npm install jsonwebtoken

      - name: Generate GitHub App Token
        id: generate-token
        env:
          APP_ID: ${{ vars.CEYX_SHARED_RESOURCES_SYNC_APP_ID }}
          PRIVATE_KEY: ${{ secrets.CEYX_SHARED_RESOURCES_SYNC_APP_PRIVATE_KEY }}
        run: |
          # Debug environment variables (masked)
          echo "APP_ID length: ${#APP_ID}"
          echo "PRIVATE_KEY length: ${#PRIVATE_KEY}"
          
          # Validate and write private key with proper formatting
          echo "Validating private key format..."
          echo "$PRIVATE_KEY" | grep -q "BEGIN RSA PRIVATE KEY" || {
            echo "Error: Private key must start with '-----BEGIN RSA PRIVATE KEY-----'"
            exit 1
          }
          
          echo "$PRIVATE_KEY" | grep -q "END RSA PRIVATE KEY" || {
            echo "Error: Private key must end with '-----END RSA PRIVATE KEY-----'"
            exit 1
          }
          
          # Write key to file, preserving newlines
          echo "$PRIVATE_KEY" > private-key.pem
          
          if [ ! -f private-key.pem ] || [ ! -s private-key.pem ]; then
            echo "Error: Failed to write private key file"
            exit 1
          fi
          
          # Debug private key file (without exposing key)
          echo "Private key file stats:"
          stat private-key.pem
          echo "Private key file line count:"
          wc -l private-key.pem
          echo "Private key structure (redacted):"
          sed 's/.*/----- REDACTED -----/' private-key.pem

          echo "Generating JWT..."
          jwt=$(node -e "
            const fs = require('fs');
            const jwt = require('jsonwebtoken');
            
            try {
              const privateKey = fs.readFileSync('private-key.pem');
              console.error('Private key loaded, length:', privateKey.length);
              
              const payload = {
                iat: Math.floor(Date.now() / 1000) - 60,
                exp: Math.floor(Date.now() / 1000) + 600,
                iss: '$APP_ID'
              };
              console.error('JWT payload:', JSON.stringify(payload));
              
              const token = jwt.sign(payload, privateKey, { algorithm: 'RS256' });
              console.error('JWT token length:', token.length);
              console.log(token);
            } catch (error) {
              console.error('Error generating JWT:', error.message);
              process.exit(1);
            }
          ")
          
          rm private-key.pem  # Clean up
          
          if [ -z "$jwt" ]; then
            echo "Failed to generate JWT token"
            exit 1
          fi
          
          # Debug JWT structure (without exposing token)
          echo "JWT token length: ${#jwt}"
          echo "JWT token structure:"
          echo "$jwt" | awk -F. '{print "Header: " $1 "\nPayload: " $2 "\nSignature: " $3}'
          
          echo "TOKEN=$jwt" >> $GITHUB_ENV

      - name: Debug Token
        if: always()
        run: |
          echo "Environment variables set:"
          env | grep -i token | sed 's/=.*/=*** (redacted)/'
          
          if [ -n "$TOKEN" ]; then
            echo "TOKEN is set, length: ${#TOKEN}"
            echo "TOKEN structure:"
            echo "$TOKEN" | awk -F. '{print "Header: " $1 "\nPayload: " $2 "\nSignature: " $3}'
          else
            echo "TOKEN is not set!"
          fi

      - name: Get Installation Token
        id: get-installation-token
        env:
          INSTALLATION_ID: ${{ vars.CEYX_SHARED_RESOURCES_SYNC_APP_INSTALLATION_ID }}
          TOKEN: ${{ env.TOKEN }}
        run: |
          echo "Retrieving installation token..."
          token_response=$(curl -sS -X POST \
            -H "Authorization: Bearer $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/app/installations/$INSTALLATION_ID/access_tokens")
          
          echo "Token response:"
          echo "$token_response" | jq -r 'del(.token)'  # Print everything except the token
          
          installation_token=$(echo "$token_response" | jq -r .token)
          if [ -z "$installation_token" ]; then
            echo "Failed to get installation token"
            exit 1
          fi
          
          echo "INSTALLATION_TOKEN=$installation_token" >> $GITHUB_ENV

      - name: Validate Installation Token
        env:
          INSTALLATION_TOKEN: ${{ env.INSTALLATION_TOKEN }}
        run: |
          echo "Validating token permissions..."
          
          # Check installation details
          echo "Checking installation details..."
          curl -sS \
            -H "Authorization: Bearer $INSTALLATION_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/app/installations | jq '.'
          
          # Check repository permissions
          echo "Checking repository permissions..."
          curl -sS \
            -H "Authorization: Bearer $INSTALLATION_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/installation/repositories | jq '.'
  
      - name: Debug Repository Permissions
        env:
          INSTALLATION_TOKEN: ${{ env.INSTALLATION_TOKEN }}
        run: |
            echo "Checking detailed repository permissions..."
            for repo in $(echo "${{ env.TARGET_REPOS }}" | tr '\n' ' '); do
              repo_name=$(echo $repo | sed 's/.*github.com\/\([^.]*\).*/\1/')
              echo "Checking $repo_name..."
              
              response=$(curl -sS \
                -H "Authorization: Bearer $INSTALLATION_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/$repo_name")
              
              echo "Full permissions for $repo_name:"
              echo "$response" | jq '.permissions'
              
              # Check installation access
              echo "Checking installation access..."
              curl -sS \
                -H "Authorization: Bearer $INSTALLATION_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/installation/repositories" | jq '.'
            done
            
      - name: Validate Repository Access
        env:
          INSTALLATION_TOKEN: ${{ env.INSTALLATION_TOKEN }}
        run: |
          for repo in $(echo "${{ env.TARGET_REPOS }}" | tr '\n' ' '); do
            repo_name=$(echo $repo | sed 's/.*github.com\/\([^.]*\).*/\1/')
            echo "Checking access to $repo_name..."
            
            response=$(curl -sS -f \
              -H "Authorization: Bearer ${{ env.INSTALLATION_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/$repo_name")
            
            if [ $? -ne 0 ]; then
              echo "Error: No access to repository $repo_name"
              exit 1
            fi
            
            # Check if we have write access
            push_access=$(echo "$response" | jq -r .permissions.push)
            if [ "$push_access" != "true" ]; then
              echo "Error: No write access to repository $repo_name"
              exit 1
            fi
          done

      - name: Sync files to target repositories
        uses: actions/github-script@v7
        env:
          INSTALLATION_TOKEN: ${{ env.INSTALLATION_TOKEN }}
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
    
            async function listFiles(dir) {
              const files = [];
              async function traverse(currentPath, relativePath = '') {
                const entries = await fs.readdir(currentPath, { withFileTypes: true });
                for (const entry of entries) {
                  const fullPath = path.join(currentPath, entry.name);
                  const relativeFinalPath = path.join(relativePath, entry.name);
                  if (entry.isDirectory()) {
                    await traverse(fullPath, relativeFinalPath);
                  } else if (!relativeFinalPath.endsWith('Zone.Identifier')) { // Skip metadata files
                    files.push({ fullPath, relativePath: relativeFinalPath });
                  }
                }
              }
              await traverse(dir);
              return files;
            }
    
            const targetRepos = process.env.TARGET_REPOS.split('\n').map(repo => {
              const match = repo.trim().match(/github\.com\/([^/]+\/[^.]+)(?:\.git)?/);
              return match ? match[1] : null;
            }).filter(Boolean);
    
            let syncErrors = 0;
    
            for (const repo of targetRepos) {
              const [owner, repoName] = repo.split('/');
              console.log(`Processing target repository: ${repo}`);
              
              try {
                const { data: repoData } = await github.rest.repos.get({
                  owner,
                  repo: repoName,
                  headers: { authorization: `token ${process.env.INSTALLATION_TOKEN}` }
                });
                
                const defaultBranch = repoData.default_branch;
                const sourceFiles = await listFiles('source-repo/resources');
    
                for (const file of sourceFiles) {
                  try {
                    const content = await fs.readFile(file.fullPath, 'base64');
                    let sha;
    
                    try {
                      const { data: existingFile } = await github.rest.repos.getContent({
                        owner,
                        repo: repoName,
                        path: file.relativePath,
                        headers: { authorization: `token ${process.env.INSTALLATION_TOKEN}` }
                      });
                      sha = existingFile.sha;
                    } catch (error) {
                      if (error.status !== 404) throw error; // 404 means file doesn't exist yet
                    }
    
                    await github.rest.repos.createOrUpdateFileContents({
                      owner,
                      repo: repoName,
                      path: file.relativePath,
                      message: `Sync file: ${file.relativePath}`,
                      content: content,
                      sha,
                      branch: defaultBranch,
                      headers: { authorization: `token ${process.env.INSTALLATION_TOKEN}` }
                    });
    
                    console.log(`Successfully synced ${file.relativePath} to ${repo}`);
                  } catch (error) {
                    console.error(`Failed to sync ${file.relativePath} to ${repo}: ${error.message}`);
                  }
                }
              } catch (error) {
                console.error(`Failed to process repository ${repo}: ${error.message}`);
                syncErrors++;
              }
            }
            
            if (syncErrors > 0) {
              core.setFailed(`Failed to sync ${syncErrors} repositories`);
            }
